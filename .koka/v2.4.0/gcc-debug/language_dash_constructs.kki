module interface language-constructs
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core = std/core = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// An alias for the empty effect.
local alias std/core/total :: E = (std/core/types/(<>) :: E) = 1;
 
//------------------------------
//#kki: type declarations
 
pub recursive type patern {
  pub con Ident(name: std/core/types/string) : (name : std/core/types/string) -> patern;
  pub con NullPat : patern;
  pub con Patpair(p1: patern, p2: patern) : (p1 : patern, p2 : patern) -> patern;
};
pub recursive type expression {
  pub con Num(n: std/core/types/int) : (n : std/core/types/int) -> expression;
  pub con EFalse : expression;
  pub con ETrue : expression;
  pub con Variable(name: std/core/types/string) : (name : std/core/types/string) -> expression;
  pub con Lambda(arg: patern, body: expression) : (arg : patern, body : expression) -> expression;
  pub con If(cond: expression, thus: expression, otherwise: expression) : (cond : expression, thus : expression, otherwise : expression) -> expression;
  pub con MLpair(e1: expression, e2: expression) : (e1 : expression, e2 : expression) -> expression;
  pub con Apply(e1: expression, e2: expression) : (e1 : expression, e2 : expression) -> expression;
  pub con Let(arg: patern, arg_val: expression, body: expression) : (arg : patern, arg_val : expression, body : expression) -> expression;
  pub con Letrec(arg: patern, arg_val: expression, body: expression) : (arg : patern, arg_val : expression, body : expression) -> expression;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Tests for the `Ident` constructor of the `:patern` type.
pub fun is-ident : (^ patern : patern) -> std/core/types/bool;
// Automatically generated. Tests for the `NullPat` constructor of the `:patern` type.
pub fun is-nullPat : (^ patern : patern) -> std/core/types/bool;
// Automatically generated. Tests for the `Patpair` constructor of the `:patern` type.
pub fun is-patpair : (^ patern : patern) -> std/core/types/bool;
// Automatically generated. Tests for the `Num` constructor of the `:expression` type.
pub fun is-num : (^ expression : expression) -> std/core/types/bool;
// Automatically generated. Tests for the `EFalse` constructor of the `:expression` type.
pub fun is-efalse : (^ expression : expression) -> std/core/types/bool;
// Automatically generated. Tests for the `ETrue` constructor of the `:expression` type.
pub fun is-etrue : (^ expression : expression) -> std/core/types/bool;
// Automatically generated. Tests for the `Variable` constructor of the `:expression` type.
pub fun is-variable : (^ expression : expression) -> std/core/types/bool;
// Automatically generated. Tests for the `Lambda` constructor of the `:expression` type.
pub fun is-lambda : (^ expression : expression) -> std/core/types/bool;
// Automatically generated. Tests for the `If` constructor of the `:expression` type.
pub fun is-if : (^ expression : expression) -> std/core/types/bool;
// Automatically generated. Tests for the `MLpair` constructor of the `:expression` type.
pub fun is-mlpair : (^ expression : expression) -> std/core/types/bool;
// Automatically generated. Tests for the `Apply` constructor of the `:expression` type.
pub fun is-apply : (^ expression : expression) -> std/core/types/bool;
// Automatically generated. Tests for the `Let` constructor of the `:expression` type.
pub fun is-let : (^ expression : expression) -> std/core/types/bool;
// Automatically generated. Tests for the `Letrec` constructor of the `:expression` type.
pub fun is-letrec : (^ expression : expression) -> std/core/types/bool;
pub fun show : (pat : patern) -> (std/core/total :: E) std/core/types/string;
pub fun show.1 : (exp : expression) -> (std/core/total :: E) std/core/types/string;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^" fun is-ident // inline size: 1
  = fn(patern: patern){
    match (patern) {
      ((language-constructs/Ident((.pat0: std/core/types/string) : std/core/types/string) : patern ) as .pat: patern)
         -> std/core/types/True;
      (.pat1: patern)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-nullPat // inline size: 1
  = fn(patern: patern){
    match (patern) {
      ((language-constructs/NullPat() : patern ) as .pat: patern)
         -> std/core/types/True;
      (.pat0: patern)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-patpair // inline size: 1
  = fn(patern: patern){
    match (patern) {
      ((language-constructs/Patpair((.pat0: patern) : patern, (.pat1: patern) : patern) : patern ) as .pat: patern)
         -> std/core/types/True;
      (.pat2: patern)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-num // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/Num((.pat0: std/core/types/int) : std/core/types/int) : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat1: expression)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-efalse // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/EFalse() : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat0: expression)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-etrue // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/ETrue() : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat0: expression)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-variable // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/Variable((.pat0: std/core/types/string) : std/core/types/string) : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat1: expression)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-lambda // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/Lambda((.pat0: patern) : patern, (.pat1: expression) : expression) : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat2: expression)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-if // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/If((.pat0: expression) : expression, (.pat1: expression) : expression, (.pat2: expression) : expression) : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat3: expression)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-mlpair // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/MLpair((.pat0: expression) : expression, (.pat1: expression) : expression) : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat2: expression)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-apply // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/Apply((.pat0: expression) : expression, (.pat1: expression) : expression) : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat2: expression)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-let // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/Let((.pat0: patern) : patern, (.pat1: expression) : expression, (.pat2: expression) : expression) : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat3: expression)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-letrec // inline size: 1
  = fn(expression: expression){
    match (expression) {
      ((language-constructs/Letrec((.pat0: patern) : patern, (.pat1: expression) : expression, (.pat2: expression) : expression) : expression ) as .pat: expression)
         -> std/core/types/True;
      (.pat3: expression)
         -> std/core/types/False;
    };
  };